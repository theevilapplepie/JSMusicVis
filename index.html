<!doctype html>
<html>
<head>
    <style type = "text/css">
        html,body {
            height: 100%;
            width: 100%;
            padding: 0;
            margin: 0;
            font-family: sans-serif;
        }
        #canvas {
            z-index: 0;
            position: fixed;
            width: 100%;
            height: 100%;
        }
        #player {
            position: fixed;
            width: 100%;
            bottom: 5px;
            color: #fff;
        }
        #player-wrapper {
            height: 50px;
            width: 600px;
            border: 1px solid rgba(185, 185, 185, 0.2);
            border-radius: 10px;
            background-color: rgba(44, 44, 44, 0.3);
            position: relative;
            left: 50%;
            display: flex;
            gap: 16px;
            justify-content: space-between;
            align-items: center;
            transition: left 1s ease-in-out;
            transform: translateX(-50%);
        }
        #player-wrapper.hidden {
            left: -284px;
        }
        #player-wrapper.hidden #player-hide {
            color: rgba(255,255,255,0.5);
        }
        #player .now_playing {
            display: flex;
            align-items: center;
            height: 95%;
            background: rgba(0, 0, 0, 0.5);
            border-top-left-radius: 10px;
            border-bottom-left-radius: 10px;
            padding-left: 4px;
            padding-right: 8px;
            gap: 5px;
            font-size: .8em;
            flex-grow: 1;
        }
        #player .icon {
            border-radius: 5px;
            border: 1px solid rgba(0, 0, 0, 0.5);
            height: 85%;
            aspect-ratio: 1;
            background: rgba(255,255,255,1);
            display: flex;
            justify-content: center;
            align-items: center;
        }
        #player .icon:hover {
            cursor: pointer;
        }
        #player .icon img {
            width: 32px;
        }
        #player .controls_group ion-icon {
            font-size: 2em;
        }
        #player .controls {
            display: flex;
            justify-content: center;
            align-items: center;
            padding-right: 3px;
        }
        #player .controls_group {
            display: flex;
            justify-content: center;
            align-items: center;
        }
        #player .controls_group div {
            display: flex;
            justify-content: center;
            align-items: center;
        }
        #player .controls_group ion-button {
            display: flex;
        }
        #player .progress .time {
            font-size: .7em;
            padding-left: 3px;
        }
        #player .hide {
            height: 100%;
            vertical-align: middle;
            background-color: rgba(0,0,0,.5);
            border-top-right-radius: 10px;
            border-bottom-right-radius: 10px;
            display: flex;
            align-items: center;
            color: rgba(255,255,255,.8);
        }
        #player .hide:hover {
            cursor: pointer;
        }
        #controls_play ion-button {
            position: relative;
            left: 2px;
        }
    </style>
    <script type="text/javascript" src="node_modules/stats.js/build/stats.min.js"></script>
    <script type="module" src="https://unpkg.com/ionicons@7.1.0/dist/ionicons/ionicons.esm.js"></script>
    <script nomodule src="https://unpkg.com/ionicons@7.1.0/dist/ionicons/ionicons.js"></script>
    <script type="text/javascript">
        function setStorage(name,value,days) {
            sessionStorage.setItem(name, value);
        }
        function getStorage(name) {
            return sessionStorage.getItem(name);
        }
    </script>
    <script type="module">

        function getRandomIntInclusive(min, max) {
            const minCeiled = Math.ceil(min);
            const maxFloored = Math.floor(max);
            return Math.floor(Math.random() * (maxFloored - minCeiled + 1) + minCeiled); // The maximum is inclusive and the minimum is inclusive
        }

        function secondsToTime(inputsec) {
            let hr = Math.trunc(inputsec / 60 / 60);
            let hrsec = hr * 60 * 60;
            let min = Math.trunc( (inputsec - hrsec) / 60 );
            let minsec = min * 60;
            let sec = Math.trunc(inputsec - hrsec - minsec);
            return String(hr).padStart(2,'0') + ':' + String(min).padStart(2,'0') + ':' + String(sec).padStart(2,'0')
        }

        var audio = new Audio();
        audio.controls = false;
        audio.loop = true;

        let bufferLength = 512;
        let dataArray = new Uint8Array(bufferLength);

        var canvas, device, gpuContext, canvasFormat, source, context, analyser, bars, bar_x, bar_width, bar_height, mid_x, mid_y, stats, yprecompute_xoffset, halfheight, max_y, max_x, yprecompute_halfheight, sliceWidth, heightChunks, xprecompute_halfheight, pixel_offset, avg_count, avg_r, avg_g, avg_b; 
        var blurPipeline, waveformPipeline, renderTexture, tempTexture, msaaTexture, waveformTexture, uniformBuffer, audioDataBuffer, colorUniformBuffer, copySampler;
        var copyPipeline, compositePipeline; // Two pipelines: one for canvas format, one for rgba8unorm
        var clearFrame = 0;
        var updateWaveform = 0;
        var sampleCount = 4; // MSAA sample count
        var lastFrameTime = 0;
        var targetFrameTime = 1000 / 80; // 60fps (30 fps = ~33.33ms per frame)
        pixel_offset = 4;
        
        avg_count = 1;
        avg_r = 0;
        avg_g = 0;
        avg_b = 0;


        window.addEventListener("load", async () => {
            // Setup Stats
            stats = new Stats();
            stats.showPanel( 0 ); // 0: fps, 1: ms, 2: mb, 3+: custom
            stats.dom.style.setProperty('right','0px');
            stats.dom.style.setProperty('left','unset');
            document.body.appendChild( stats.dom );

            // Setup Canvas and WebGPU
            canvas = document.getElementById('canvas');
            window.addEventListener('resize', resizeCanvas, false);
            
            // Initialize WebGPU
            if (!navigator.gpu) {
                alert("WebGPU not supported on this browser.");
                return;
            }
            
            const adapter = await navigator.gpu.requestAdapter();
            if (!adapter) {
                alert("Failed to get GPU adapter.");
                return;
            }
            
            device = await adapter.requestDevice();
            gpuContext = canvas.getContext('webgpu');
            
            canvasFormat = navigator.gpu.getPreferredCanvasFormat();
            gpuContext.configure({
                device: device,
                format: canvasFormat,
                alphaMode: 'opaque'
            });
            
            await initWebGPUPipelines();
            await initCopyPipeline();
            resizeCanvas();

            // Setup Audio
            document.getElementById('player_file').addEventListener('change', (e) => {
                if ( e.currentTarget.files.length == 0 ) {
                    return;
                }
                audio.pause();
                audio.currentTime=0;
                audio.src = URL.createObjectURL(e.currentTarget.files[0]);
                setStorage('playback_file',audio.src,7);
                document.getElementById('player-title').innerHTML = e.currentTarget.files[0].name;
                document.getElementById('player-artist').innerHTML = '';
                //processID3(e.currentTarget.files[0]);
                audio.play();
            });

            let slider = document.getElementById('player_slider');
            slider.addEventListener('input', (e) => {
                audio.currentTime = slider.value;
            });
            slider.addEventListener('mousedown',(e) => {
                audio.pause();
            });
            slider.addEventListener('mouseup',(e) => {
                audio.play();
            });
            document.body.appendChild(audio);
            audio.addEventListener("play", initMp3Player );
            audio.addEventListener('play', (e) => {
                setStorage('playback_state','playing',0);
                document.getElementById('controls_play').style.display = 'none';
                document.getElementById('controls_pause').style.display = 'inherit';
                slider.max = audio.duration;
                document.getElementById('player_duration').innerHTML = secondsToTime(audio.duration);
                window.requestAnimationFrame(frameLooper);
            });
            audio.addEventListener('pause', (e) => {
                setStorage('playback_state','paused',0);
                document.getElementById('controls_play').style.display = 'inherit';
                document.getElementById('controls_pause').style.display = 'none';
            });                
            audio.addEventListener("volumechange", (e) => {
                setStorage('playback_vol',audio.volume,7);
            });
            audio.addEventListener("timeupdate", (event) => {
                slider.max = audio.duration;
                if ( ! audio.paused ) {
                    slider.value = audio.currentTime;
                    setStorage('playback_timeindex',audio.currentTime,7);
                }
                document.getElementById('player_runtime').innerHTML = secondsToTime(audio.currentTime);
                document.getElementById('player_duration').innerHTML = secondsToTime(audio.duration);
            });
            let last_src = getStorage('playback_file');
            if ( last_src ) {
                audio.src = last_src;
            }
            // I just want temporary reloadability without having to manually load the file
            audio.src = "/music.opus";
            //document.getElementById('player-title').innerHTML = "music.opus";
            //document.getElementById('player-artist').innerHTML = '';
            let last_vol = getStorage('playback_vol');
            if ( last_vol ) {
                audio.volume = last_vol;
            }
            let last_ti = getStorage('playback_timeindex');
            if ( last_ti ) {
                audio.currentTime = last_ti;
            }
            document.getElementById('controls_play').children[0].addEventListener("click", (e) => {
                audio.play();
            });
            document.getElementById('controls_pause').children[0].addEventListener("click", (e) => {
                audio.pause();
            });

            if ( getStorage('playback_state') == 'playing' ) {
                audio.play();
            }
            
            // Setup hide/show player toggle
            document.getElementById('player-hide').addEventListener('click', (e) => {
                const wrapper = document.getElementById('player-wrapper');
                const hideBack = document.getElementById('hide-back');
                const hideForward = document.getElementById('hide-forward');
                
                wrapper.classList.toggle('hidden');
                
                if (wrapper.classList.contains('hidden')) {
                    hideBack.style.display = 'none';
                    hideForward.style.display = 'block';
                } else {
                    hideBack.style.display = 'block';
                    hideForward.style.display = 'none';
                }
            });
        }, false);

        // We do this to avoid a weird race condition with audio element loading
        function initMp3Player(){
            audio.removeEventListener("play", initMp3Player);
            context = new AudioContext();
            analyser = context.createAnalyser();
            analyser.fftSize = bufferLength;
            source = context.createMediaElementSource(audio);
            source.connect(analyser);
            analyser.connect(context.destination);
            setInterval( () => {
                clearFrame = 1;
            }, 100);
            setInterval( () => {
                updateWaveform = 1;
            }, 50);
        }

        // Helper pipeline to copy between different texture formats
        var copyPipeline;
        async function initCopyPipeline() {
            const copyShader = `
                struct VertexOutput {
                    @builtin(position) position: vec4<f32>,
                    @location(0) texCoord: vec2<f32>,
                }

                @vertex
                fn vertMain(@builtin(vertex_index) vertexIndex: u32) -> VertexOutput {
                    var pos = array<vec2<f32>, 6>(
                        vec2<f32>(-1.0, -1.0),
                        vec2<f32>(1.0, -1.0),
                        vec2<f32>(-1.0, 1.0),
                        vec2<f32>(-1.0, 1.0),
                        vec2<f32>(1.0, -1.0),
                        vec2<f32>(1.0, 1.0)
                    );
                    var texCoord = array<vec2<f32>, 6>(
                        vec2<f32>(0.0, 1.0),
                        vec2<f32>(1.0, 1.0),
                        vec2<f32>(0.0, 0.0),
                        vec2<f32>(0.0, 0.0),
                        vec2<f32>(1.0, 1.0),
                        vec2<f32>(1.0, 0.0)
                    );
                    var output: VertexOutput;
                    output.position = vec4<f32>(pos[vertexIndex], 0.0, 1.0);
                    output.texCoord = texCoord[vertexIndex];
                    return output;
                }

                @group(0) @binding(0) var srcTexture: texture_2d<f32>;
                @group(0) @binding(1) var srcSampler: sampler;

                @fragment
                fn fragMain(input: VertexOutput) -> @location(0) vec4<f32> {
                    return textureSample(srcTexture, srcSampler, input.texCoord);
                }
            `;

            const copyModule = device.createShaderModule({ code: copyShader });
            copyPipeline = device.createRenderPipeline({
                layout: 'auto',
                vertex: {
                    module: copyModule,
                    entryPoint: 'vertMain'
                },
                fragment: {
                    module: copyModule,
                    entryPoint: 'fragMain',
                    targets: [{
                        format: canvasFormat
                    }]
                },
                primitive: {
                    topology: 'triangle-list'
                }
            });
            
            // Create composite pipeline for rgba8unorm with blending
            compositePipeline = device.createRenderPipeline({
                layout: 'auto',
                vertex: {
                    module: copyModule,
                    entryPoint: 'vertMain'
                },
                fragment: {
                    module: copyModule,
                    entryPoint: 'fragMain',
                    targets: [{
                        format: 'rgba8unorm',
                        blend: {
                            color: {
                                srcFactor: 'src-alpha',
                                dstFactor: 'one-minus-src-alpha',
                                operation: 'add'
                            },
                            alpha: {
                                srcFactor: 'one',
                                dstFactor: 'one-minus-src-alpha',
                                operation: 'add'
                            }
                        }
                    }]
                },
                primitive: {
                    topology: 'triangle-list'
                }
            });
        }

        async function initWebGPUPipelines() {
            // Compute shader for blur effect
            const blurShader = `
                @group(0) @binding(0) var inputTex: texture_2d<f32>;
                @group(0) @binding(1) var outputTex: texture_storage_2d<rgba8unorm, write>;
                @group(0) @binding(2) var<uniform> uniforms: Uniforms;

                struct Uniforms {
                    width: u32,
                    height: u32,
                    clearFrame: u32,
                }

                @compute @workgroup_size(8, 8)
                fn main(@builtin(global_invocation_id) global_id: vec3<u32>) {
                    let x = global_id.x;
                    let y = global_id.y;
                    
                    if (x >= uniforms.width || y >= uniforms.height) {
                        return;
                    }

                    let halfHeight = uniforms.height / 2u;
                    let coords = vec2<i32>(i32(x), i32(y));
                    let currentColor = textureLoad(inputTex, coords, 0);
                    
                    var newColor: vec4<f32> = currentColor;

                    var totalPixels = 0u;
                    var newColor_r = newColor.r;
                    var newColor_g = newColor.g;
                    var newColor_b = newColor.b;
                    // These two cannot be greater than 1
                    let curColorMix = 0.5;
                    let tmpColorMix = 0.5;
                    let falloff = 0.005;

                    if ( x >= 0 ) {
                        let lftCoords = vec2<i32>(i32(x) - 1, i32(y));
                        var tmpColor = textureLoad(inputTex, lftCoords, 0);
                        newColor_r = (newColor_r * curColorMix) + (tmpColor.r * tmpColorMix);
                        newColor_g = (newColor_g * curColorMix) + (tmpColor.g * tmpColorMix);
                        newColor_b = (newColor_b * curColorMix) + (tmpColor.b * tmpColorMix);
                        totalPixels++;
                    }
                    if ( x < uniforms.width && false ) {
                        let rgtCoords = vec2<i32>(i32(x) + 1, i32(y));
                        var tmpColor = textureLoad(inputTex, rgtCoords, 0);
                        newColor_r = (newColor_r * curColorMix) + (tmpColor.r * tmpColorMix);
                        newColor_g = (newColor_g * curColorMix) + (tmpColor.g * tmpColorMix);
                        newColor_b = (newColor_b * curColorMix) + (tmpColor.b * tmpColorMix);
                        totalPixels++;
                    }
                    if ( y > 0 ) {
                        let upCoords = vec2<i32>(i32(x), i32(y) - 1);
                        let tmpColor = textureLoad(inputTex, upCoords, 0);
                        newColor_r = (newColor_r * curColorMix) + (tmpColor.r * tmpColorMix);
                        newColor_g = (newColor_g * curColorMix) + (tmpColor.g * tmpColorMix);
                        newColor_b = (newColor_b * curColorMix) + (tmpColor.b * tmpColorMix);
                        totalPixels++;
                        if ( x > 0 ) {
                            let lftCoords = vec2<i32>(i32(x) - 1, i32(y) - 1);
                            var tmpColor = textureLoad(inputTex, lftCoords, 0);
                            newColor_r = (newColor_r * curColorMix) + (tmpColor.r * tmpColorMix);
                            newColor_g = (newColor_g * curColorMix) + (tmpColor.g * tmpColorMix);
                            newColor_b = (newColor_b * curColorMix) + (tmpColor.b * tmpColorMix);
                            totalPixels++;
                        }
                        if ( x < uniforms.width && false ) {
                            let rgtCoords = vec2<i32>(i32(x) + 1, i32(y) - 1);
                            var tmpColor = textureLoad(inputTex, rgtCoords, 0);
                            newColor_r = (newColor_r * curColorMix) + (tmpColor.r * tmpColorMix);
                            newColor_g = (newColor_g * curColorMix) + (tmpColor.g * tmpColorMix);
                            newColor_b = (newColor_b * curColorMix) + (tmpColor.b * tmpColorMix);
                            totalPixels++;
                        }
                    }
                    if ( y < uniforms.height ) {
                        let dnCoords = vec2<i32>(i32(x), i32(y) + 1);
                        let tmpColor = textureLoad(inputTex, dnCoords, 0);
                        newColor_r = (newColor_r * curColorMix) + (tmpColor.r * tmpColorMix);
                        newColor_g = (newColor_g * curColorMix) + (tmpColor.g * tmpColorMix);
                        newColor_b = (newColor_b * curColorMix) + (tmpColor.b * tmpColorMix);
                        totalPixels++;
                        if ( x > 0 ) {
                            let lftCoords = vec2<i32>(i32(x) - 1, i32(y) + 1);
                            var tmpColor = textureLoad(inputTex, lftCoords, 0);
                            newColor_r = (newColor_r * curColorMix) + (tmpColor.r * tmpColorMix);
                            newColor_g = (newColor_g * curColorMix) + (tmpColor.g * tmpColorMix);
                            newColor_b = (newColor_b * curColorMix) + (tmpColor.b * tmpColorMix);
                            totalPixels++;
                        }
                        if ( x < uniforms.width && false) {
                            let rgtCoords = vec2<i32>(i32(x) + 1, i32(y) + 1);
                            var tmpColor = textureLoad(inputTex, rgtCoords, 0);
                            newColor_r = (newColor_r * curColorMix) + (tmpColor.r * tmpColorMix);
                            newColor_g = (newColor_g * curColorMix) + (tmpColor.g * tmpColorMix);
                            newColor_b = (newColor_b * curColorMix) + (tmpColor.b * tmpColorMix);
                            totalPixels++;
                        }                        
                    }
                    if ( uniforms.clearFrame == 1u ) {
                        newColor = vec4<f32>(
                            max(newColor_r - falloff, 0.0),
                            max(newColor_g - falloff, 0.0),
                            max(newColor_b - falloff, 0.0),
                            1.0
                        );
                    } else {
                        newColor = vec4<f32>(
                            max(newColor_r, 0.0),
                            max(newColor_g, 0.0),
                            max(newColor_b, 0.0),
                            1.0
                        );
                    }
                
                    textureStore(outputTex, coords, newColor);
                }
            `;

            // Waveform vertex shader
            const waveformVertexShader = `
                struct VertexOutput {
                    @builtin(position) position: vec4<f32>,
                }

                @group(0) @binding(0) var<storage, read> audioData: array<f32>;
                @group(0) @binding(1) var<uniform> uniforms: WaveUniforms;

                struct WaveUniforms {
                    width: f32,
                    height: f32,
                    midY: f32,
                    heightChunks: f32,
                    bufferLength: u32,
                    sliceWidth: f32,
                    lineWidth: f32,
                }

                @vertex
                fn main(@builtin(vertex_index) vertexIndex: u32) -> VertexOutput {
                    var output: VertexOutput;
                    
                    // Each audio sample generates 6 vertices (2 triangles for a quad)
                    let audioIndex = vertexIndex / 6u;
                    let vertexInQuad = vertexIndex % 6u;
                    
                    if (audioIndex >= uniforms.bufferLength - 1u) {
                        output.position = vec4<f32>(0.0, 0.0, 0.0, 0.0);
                        return output;
                    }
                    
                    // Get current and next audio values
                    let value1 = audioData[audioIndex] - 128.0;
                    let value2 = audioData[audioIndex + 1u] - 128.0;
                    
                    let x1 = f32(audioIndex) * uniforms.sliceWidth;
                    let y1 = uniforms.midY + (value1 * uniforms.heightChunks);
                    let x2 = f32(audioIndex + 1u) * uniforms.sliceWidth;
                    let y2 = uniforms.midY + (value2 * uniforms.heightChunks);
                    
                    // Calculate perpendicular offset for line thickness
                    let dx = x2 - x1;
                    let dy = y2 - y1;
                    let len = sqrt(dx * dx + dy * dy);
                    var perpX = 0.0;
                    var perpY = 0.0;
                    if (len > 0.0) {
                        perpX = -dy / len * uniforms.lineWidth;
                        perpY = dx / len * uniforms.lineWidth;
                    }
                    
                    // Generate quad vertices
                    var x: f32;
                    var y: f32;
                    
                    if (vertexInQuad == 0u) {
                        x = x1 + perpX;
                        y = y1 + perpY;
                    } else if (vertexInQuad == 1u) {
                        x = x1 - perpX;
                        y = y1 - perpY;
                    } else if (vertexInQuad == 2u) {
                        x = x2 + perpX;
                        y = y2 + perpY;
                    } else if (vertexInQuad == 3u) {
                        x = x2 + perpX;
                        y = y2 + perpY;
                    } else if (vertexInQuad == 4u) {
                        x = x1 - perpX;
                        y = y1 - perpY;
                    } else {
                        x = x2 - perpX;
                        y = y2 - perpY;
                    }
                    
                    // Convert to NDC
                    let ndcX = (x / uniforms.width) * 2.0 - 1.0;
                    let ndcY = 1.0 - (y / uniforms.height) * 2.0;
                    
                    output.position = vec4<f32>(ndcX, ndcY, 0.0, 1.0);
                    return output;
                }
            `;

            // Waveform fragment shader
            const waveformFragmentShader = `
                @group(0) @binding(2) var<uniform> color: vec4<f32>;

                @fragment
                fn main() -> @location(0) vec4<f32> {
                    return color;
                }
            `;

            // Create compute pipeline for blur
            const blurModule = device.createShaderModule({ code: blurShader });
            blurPipeline = device.createComputePipeline({
                layout: 'auto',
                compute: {
                    module: blurModule,
                    entryPoint: 'main'
                }
            });

            // Create render pipeline for waveform
            const waveformVertModule = device.createShaderModule({ code: waveformVertexShader });
            const waveformFragModule = device.createShaderModule({ code: waveformFragmentShader });
            
            waveformPipeline = device.createRenderPipeline({
                layout: 'auto',
                vertex: {
                    module: waveformVertModule,
                    entryPoint: 'main'
                },
                fragment: {
                    module: waveformFragModule,
                    entryPoint: 'main',
                    targets: [{
                        format: 'rgba8unorm',
                        blend: {
                            color: {
                                srcFactor: 'src-alpha',
                                dstFactor: 'one-minus-src-alpha',
                                operation: 'add'
                            },
                            alpha: {
                                srcFactor: 'one',
                                dstFactor: 'one-minus-src-alpha',
                                operation: 'add'
                            }
                        }
                    }]
                },
                primitive: {
                    topology: 'triangle-list'
                },
                multisample: {
                    count: 4
                }
            });
        }

        function resizeCanvas() {
            // Render at higher resolution and scale down for better quality
            const scaleFactor = 1.3;
            canvas.width = canvas.clientWidth * scaleFactor;
            canvas.height = canvas.clientHeight * scaleFactor;
            
            // Clean up old resources
            if (renderTexture) renderTexture.destroy();
            if (tempTexture) tempTexture.destroy();
            if (msaaTexture) msaaTexture.destroy();
            if (waveformTexture) waveformTexture.destroy();
            if (uniformBuffer) uniformBuffer.destroy();
            if (audioDataBuffer) audioDataBuffer.destroy();
            if (colorUniformBuffer) colorUniformBuffer.destroy();
            
            // Create render textures for blur effect (ping-pong buffers)
            // Use rgba8unorm because bgra8unorm doesn't support storage binding
            renderTexture = device.createTexture({
                size: [canvas.width, canvas.height],
                format: 'rgba8unorm',
                usage: GPUTextureUsage.TEXTURE_BINDING | 
                       GPUTextureUsage.STORAGE_BINDING | 
                       GPUTextureUsage.COPY_SRC |
                       GPUTextureUsage.COPY_DST |
                       GPUTextureUsage.RENDER_ATTACHMENT
            });

            tempTexture = device.createTexture({
                size: [canvas.width, canvas.height],
                format: 'rgba8unorm',
                usage: GPUTextureUsage.TEXTURE_BINDING | 
                       GPUTextureUsage.STORAGE_BINDING | 
                       GPUTextureUsage.COPY_SRC |
                       GPUTextureUsage.COPY_DST |
                       GPUTextureUsage.RENDER_ATTACHMENT
            });

            // Create separate texture for waveform rendering with MSAA
            waveformTexture = device.createTexture({
                size: [canvas.width, canvas.height],
                format: 'rgba8unorm',
                usage: GPUTextureUsage.TEXTURE_BINDING | 
                       GPUTextureUsage.RENDER_ATTACHMENT
            });

            // Create MSAA texture for antialiasing
            msaaTexture = device.createTexture({
                size: [canvas.width, canvas.height],
                format: 'rgba8unorm',
                sampleCount: sampleCount,
                usage: GPUTextureUsage.RENDER_ATTACHMENT
            });

            // Create uniform buffer for compute shader
            uniformBuffer = device.createBuffer({
                size: 16, // 4 x u32
                usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST
            });

            // Create audio data buffer
            audioDataBuffer = device.createBuffer({
                size: bufferLength * 4, // f32 array
                usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST
            });

            // Create color uniform buffer
            colorUniformBuffer = device.createBuffer({
                size: 28, // width, height, midY, heightChunks, bufferLength, sliceWidth, lineWidth
                usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST
            });

            // Create sampler for texture copying
            if (!copySampler) {
                copySampler = device.createSampler({
                    magFilter: 'nearest',
                    minFilter: 'nearest'
                });
            }
            
            // Now setup variables we use in the drawing loop
            mid_x = canvas.width / 2;
            mid_y = canvas.height / 2;
            yprecompute_xoffset = canvas.width * 4;
            yprecompute_halfheight = mid_y * yprecompute_xoffset;
            xprecompute_halfheight = yprecompute_xoffset / 2;
            max_y = canvas.height * yprecompute_xoffset;
            max_x = canvas.width * 4;

            if ( canvas.width > bufferLength ) {
                sliceWidth =  canvas.width / bufferLength;
            } else {
                sliceWidth =  bufferLength / canvas.width;
            }
            // Adjust height chunks based on canvas size
            // The last parameter is vertical scaling
            heightChunks = (canvas.height / 256) * .8;
            avg_count = (canvas.width * canvas.height) / 8;
            
            // Clear the canvas
            const encoder = device.createCommandEncoder();
            const canvasTexture = gpuContext.getCurrentTexture();
            const renderPass = encoder.beginRenderPass({
                colorAttachments: [{
                    view: canvasTexture.createView(),
                    loadOp: 'clear',
                    clearValue: { r: 0, g: 0, b: 0, a: 1 },
                    storeOp: 'store'
                }]
            });
            renderPass.end();
            device.queue.submit([encoder.finish()]);
        }

        function frameLooper(currentTime){

            // Short cirucuit if paused
            if ( audio.paused ) {
                return;
            }

            // Cap framerate at 60 fps
            const deltaTime = currentTime - lastFrameTime;
            if (deltaTime < targetFrameTime) {
                return window.requestAnimationFrame(frameLooper);
            }
            lastFrameTime = currentTime;

            stats.begin();

            const encoder = device.createCommandEncoder();
            
            // Get current canvas texture
            const canvasTexture = gpuContext.getCurrentTexture();
            
            // Run blur compute shader
            {
                const uniformData = new Uint32Array([
                    canvas.width,
                    canvas.height,
                    clearFrame,
                ]);
                device.queue.writeBuffer(uniformBuffer, 0, uniformData);

                const bindGroup = device.createBindGroup({
                    layout: blurPipeline.getBindGroupLayout(0),
                    entries: [
                        { binding: 0, resource: renderTexture.createView() },
                        { binding: 1, resource: tempTexture.createView() },
                        { binding: 2, resource: { buffer: uniformBuffer } }
                    ]
                });

                const passEncoder = encoder.beginComputePass();
                passEncoder.setPipeline(blurPipeline);
                passEncoder.setBindGroup(0, bindGroup);
                passEncoder.dispatchWorkgroups(
                    Math.ceil(canvas.width / 8),
                    Math.ceil(canvas.height / 8)
                );
                passEncoder.end();
                clearFrame = 0;
            }

            // Are we an update frame for the waveform?
            if ( updateWaveform ) {
                // Get audio data
                analyser.getByteTimeDomainData(dataArray);
                
                // Upload audio data to GPU
                const audioDataFloat = new Float32Array(bufferLength);
                for (let i = 0; i < bufferLength; i++) {
                    audioDataFloat[i] = dataArray[i];
                }
                device.queue.writeBuffer(audioDataBuffer, 0, audioDataFloat);

                // Update color values
                let new_r, new_g, new_b;
                if ( isNaN(avg_r) || isNaN(avg_g) || isNaN(avg_b) || // if averages are not set
                     ((avg_r - avg_g) < 50 && (avg_g - avg_b) < 50  && (avg_b - avg_g) < 50) || // if the different values are too similar ( eg: bland )
                     ( avg_r < 128 && avg_g < 128 && avg_b < 128 ) // if it's not bright enough
                ) {
                    while ( avg_r < 200 && avg_g < 200 && avg_b < 200 ) {
                        avg_r = getRandomIntInclusive(0,255);
                        avg_g = getRandomIntInclusive(0,255);
                        avg_b = getRandomIntInclusive(0,255);
                    }
                }

                avg_r = Math.min(avg_r + getRandomIntInclusive(0,20), 255);
                avg_r = Math.max(avg_r - getRandomIntInclusive(0,20),0);
                
                avg_g = Math.min(avg_g + getRandomIntInclusive(0,20), 255);
                avg_g = Math.max(avg_g - getRandomIntInclusive(0,20),0);

                avg_b = Math.min(avg_b + getRandomIntInclusive(0,20), 255);
                avg_b = Math.max(avg_b - getRandomIntInclusive(0,20),0);

                // Create waveform uniforms buffer
                const waveformColorBuffer = device.createBuffer({
                    size: 16, // vec4<f32>
                    usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST
                });
                const colorData = new Float32Array([
                    avg_r / 255, avg_g / 255, avg_b / 255, 1.0
                ]);
                device.queue.writeBuffer(waveformColorBuffer, 0, colorData);

                // Update waveform uniforms
                const waveformUniformsData = new Float32Array([
                    canvas.width,
                    canvas.height,
                    mid_y,
                    heightChunks,
                    bufferLength,
                    sliceWidth,
                    1.0  // line width in pixels
                ]);
                device.queue.writeBuffer(colorUniformBuffer, 0, waveformUniformsData);

                // Create separate buffers for shadow pass
                const shadowUniformsBuffer = device.createBuffer({
                    size: 28,
                    usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST
                });
                
                const shadowColorBuffer = device.createBuffer({
                    size: 16,
                    usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST
                });
                
                // Shadow uniforms (thicker line)
                const shadowUniformsData = new Float32Array([
                    canvas.width,
                    canvas.height,
                    mid_y,
                    heightChunks,
                    bufferLength,
                    sliceWidth,
                    3.0  // shadow line width (much thicker)
                ]);
                device.queue.writeBuffer(shadowUniformsBuffer, 0, shadowUniformsData);
                
                // Shadow color (black with transparency)
                const shadowColorData = new Float32Array([0.0, 0.0, 0.0, 1.0]);
                device.queue.writeBuffer(shadowColorBuffer, 0, shadowColorData);

                // Draw waveform on renderTexture with shadow
                {
                    const bindGroup = device.createBindGroup({
                        layout: waveformPipeline.getBindGroupLayout(0),
                        entries: [
                            { binding: 0, resource: { buffer: audioDataBuffer } },
                            { binding: 1, resource: { buffer: colorUniformBuffer } },
                            { binding: 2, resource: { buffer: waveformColorBuffer } }
                        ]
                    });

                    // Draw waveform to separate texture with MSAA
                    const renderPass = encoder.beginRenderPass({
                        colorAttachments: [{
                            view: msaaTexture.createView(),
                            resolveTarget: waveformTexture.createView(),
                            loadOp: 'clear',
                            clearValue: { r: 0, g: 0, b: 0, a: 0 },
                            storeOp: 'store'
                        }]
                    });

                    renderPass.setPipeline(waveformPipeline);
                    
                    // Draw shadow first with separate buffers
                    const shadowBindGroup = device.createBindGroup({
                        layout: waveformPipeline.getBindGroupLayout(0),
                        entries: [
                            { binding: 0, resource: { buffer: audioDataBuffer } },
                            { binding: 1, resource: { buffer: shadowUniformsBuffer } },
                            { binding: 2, resource: { buffer: shadowColorBuffer } }
                        ]
                    });
                    
                    renderPass.setBindGroup(0, shadowBindGroup);
                    renderPass.draw((bufferLength - 1) * 6);
                    
                    // Draw actual waveform on top with original buffers
                    const mainBindGroup = device.createBindGroup({
                        layout: waveformPipeline.getBindGroupLayout(0),
                        entries: [
                            { binding: 0, resource: { buffer: audioDataBuffer } },
                            { binding: 1, resource: { buffer: colorUniformBuffer } },
                            { binding: 2, resource: { buffer: waveformColorBuffer } }
                        ]
                    });
                    
                    renderPass.setBindGroup(0, mainBindGroup);
                    renderPass.draw((bufferLength - 1) * 6);
                    
                    renderPass.end();
                }

                // Composite waveform over blurred background
                {
                    const bindGroup = device.createBindGroup({
                        layout: compositePipeline.getBindGroupLayout(0),
                        entries: [
                            { binding: 0, resource: waveformTexture.createView() },
                            { binding: 1, resource: copySampler }
                        ]
                    });

                    const renderPass = encoder.beginRenderPass({
                        colorAttachments: [{
                            view: tempTexture.createView(),
                            loadOp: 'load',
                            storeOp: 'store'
                        }]
                    });

                    renderPass.setPipeline(compositePipeline);
                    renderPass.setBindGroup(0, bindGroup);
                    renderPass.draw(6);
                    renderPass.end();
                }

                updateWaveform = 0;
            }

            // Copy final result to canvas texture using render pass (handles format conversion)
            {
                const bindGroup = device.createBindGroup({
                    layout: copyPipeline.getBindGroupLayout(0),
                    entries: [
                        { binding: 0, resource: tempTexture.createView() },
                        { binding: 1, resource: copySampler }
                    ]
                });

                const renderPass = encoder.beginRenderPass({
                    colorAttachments: [{
                        view: canvasTexture.createView(),
                        loadOp: 'load',
                        storeOp: 'store'
                    }]
                });

                renderPass.setPipeline(copyPipeline);
                renderPass.setBindGroup(0, bindGroup);
                renderPass.draw(6);
                renderPass.end();
            }


            // Copy tempTexture back to renderTexture for next frame
            encoder.copyTextureToTexture(
                { texture: tempTexture },
                { texture: renderTexture },
                [canvas.width, canvas.height]
            );

            device.queue.submit([encoder.finish()]);

            stats.end();

            return window.requestAnimationFrame(frameLooper);
        }


   </script>
</head>

<body>
    <canvas id="canvas"></canvas>
    <div id="player">
        <input hidden type="file" id="player_file">
        <div id="player-wrapper">
            <div class="now_playing">
                <div class="icon" onClick="document.getElementById('player_file').click();"><img src="compact-disk.png"></div>
                <div class="meta">
                    <div id="player-title">Click disc and</div>
                    <div id="player-artist">select a music file</div>
                </div>
            </div>
            <div class="controls">
                <div class="controls_group">
                    <div class="prev"><ion-icon name="chevron-back"></ion-icon></div>
                    <div id="controls_play">
                        <ion-button icon-only fill="clear">
                            <ion-icon name="play-sharp"></ion-icon>
                        </ion-button>
                    </div>
                    <div id="controls_pause" style="display: none;">
                        <ion-button icon-only fill="clear">
                            <ion-icon name="pause-sharp"></ion-icon>
                        </ion-button>
                    </div>
                    <div class="next"><ion-icon name="chevron-forward"></ion-icon></div>
                </div>
                <div class="progress">
                    <input type="range" min="0" max="100" value="0" class="slider" id="player_slider">
                    <div class="time"><span id="player_runtime">00:00</span> / <span id="player_duration">00:00</span></div>
                </div>
            </div>
            <div class="volume"></div>
            <div class="hide" id="player-hide">
                <ion-icon id="hide-back" name="chevron-back-outline"></ion-icon>
                <ion-icon id="hide-forward" name="chevron-forward-outline" style="display: none;"></ion-icon>
            </div>
        </div>
    </div>
</body>
</html>
